Problem Summary:
You're given an array nums. Determine if it can be formed by rotating a non-decreasing sorted array any number of times (including 0 times). The array may contain duplicates.

NOTICE: 
ğŸ‘‰ In a rotated sorted array, the array will have at most one "drop" â€” where a number is greater than its next one.

Thatâ€™s the key observation!
------------------------------------------
ğŸ” WHAT IS A "DROP"?
A â€œdropâ€ is when nums[i] > nums[i+1]

In a normally sorted array: No drops

In a rotated sorted array: One drop (e.g. [3, 4, 5, 1, 2] â€” drop at 5 â†’ 1)

More than one drop? â†’ Invalid

Special case: The array wraps around! So we check (nums[-1] > nums[0]) too!
------------------------------------------
âœ… Approach
Count how many times nums[i] > nums[i+1]

Add one more check for nums[-1] > nums[0] (wrap-around)

If the number of such drops is more than 1, return False

Else, return True
-----------------------------------------
ğŸ§  Example Walkthrough
Example: [3, 4, 5, 1, 2]

3 < 4 â†’ ok

4 < 5 â†’ ok

5 > 1 â†’ drop âœ…

1 < 2 â†’ ok

Wrap-around: 2 < 3 â†’ ok

1 drop â†’ âœ… return True

Example: [2, 1, 3, 4]

2 > 1 â†’ drop âœ…

1 < 3 â†’ ok

3 < 4 â†’ ok

Wrap-around: 4 > 2 â†’ another drop âŒ

2 drops â†’ return False
---------------------------------------
CODE

#include <vector>
using namespace std;

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        int n = nums.size();

        for (int i = 0; i < n - 1; ++i) {
            if (nums[i] > nums[i + 1]) {
                count++;
            }
        }

        // Check the wrap-around pair
        if (nums[n - 1] > nums[0]) {
            count++;
        }

        return count <= 1;
    }
};
